-- RPG NPC by Todd Ross
-- http://steamcommunity.com/sharedfiles/filedetails/?id=1198422406

local debug = false
local pleaDelay = 120
local pleaDisplaySeconds = 10

local enabled = false
local pleaText = nil

function emptyFunction() return end



--- BEGIN STATE MANAGEMENT ---

function onLoad(loadString)
	if string.len(loadString) > 0 then
		local saveState = JSON.decode(loadString)
		enabled = saveState.enabled
		pleaText = saveState.pleaText
	end
	createControlButton()
end

function onSave()
	return JSON.encode({
		enabled = enabled,
		pleaText = pleaText
	})
end

--- END STATE MANAGEMENT ---




--- BEGIN CONTROL PANEL ---

function createControlButton()
	local data = {click_function = 'createControlPanel', function_owner = self, label = "", position = {0, -0.2, 0}, rotation = {180, 0, 0}, scale = {0.5, 0.5, 0.5}, width = 400, height = 400, font_size = 400, color = {1, 0, 0, 1}}
	self.createButton(data)
end

local controlPanel = nil
function createControlPanel()
	if controlPanel and getObjectFromGUID(controlPanel.getGUID()) then return	end

	local targetPosition = self.getPosition()
	targetPosition.y = targetPosition.y + 4 -- placeholder

	controlPanel = spawnObject({
		type = 'BlockSquare',
		position = targetPosition,
		scale = { x = 10, y = 0.1, z = 10 },
		callback = 'createControlPanelCallback',
		callback_owner = self
	})
end

function createControlPanelCallback()
	controlPanel.setColorTint({ r = 0 , g = 0 , b = 0 })

	local windowTitleData = {click_function = 'emptyFunction', function_owner = self, label = "RPG NPC Figurine Control", position = {0.05, 0.6, 0.45}, rotation = {0, 180, 0}, scale = {0.1, 1, 0.1}, width = 0, height = 0, font_size = 400, font_color = { 1, 1, 1, 1 }}
	controlPanel.createButton(windowTitleData)

	local closeButtonData = {click_function = 'clickControlPanelButtonClose', function_owner = self, label = "X", position = {-0.45, 0.6, 0.45}, rotation = {0, 180, 0}, scale = {0.1, 1, 0.1}, width = 400, height = 400, font_size = 400}
	controlPanel.createButton(closeButtonData)

	local enabledLabelData = {click_function = 'emptyFunction', function_owner = self, label = "Enabled:", position = {0.3, 0.6, 0.35}, rotation = {0, 180, 0}, scale = {0.1, 1, 0.1}, width = 0, height = 0, font_size = 400, font_color = {1, 1, 1, 1}}
	controlPanel.createButton(enabledLabelData)

	local toggleEnableButtonData = {click_function = 'clickControlPanelButtonEnable', function_owner = self, label = (enabled and 'Y' or 'N'), position = {0, 0.6, 0.35}, rotation = {0, 180, 0}, scale = {0.1, 1, 0.1}, width = 400, height = 400, font_size = 400}
	controlPanel.createButton(toggleEnableButtonData)

	local pleaLabelData = {click_function = 'emptyFunction', function_owner = self, label = "Plea:", position = {0.3, 0.6, 0.25}, rotation = {0, 180, 0}, scale = {0.1, 1, 0.1}, width = 0, height = 0, font_size = 400, font_color = {1, 1, 1, 1}}
	controlPanel.createButton(pleaLabelData)

	local pleaInputData = {input_function = 'inputControlPanelInputPlea', function_owner = self, value = pleaText, position = {-0.15, 0.6, 0.25}, rotation = {0, 180, 0}, scale = {0.1, 1, 0.1}, width = 2000, height = 420, font_size = 400}
	controlPanel.createInput(pleaInputData)
end

function clickControlPanelButtonClose()
	destroyControlPanel()
end

function clickControlPanelButtonEnable()
	enabled = not enabled
	refreshControlPanel()
end

function inputControlPanelInputPlea(objectInputTyped, playerColorTyped, input_value, selected)
	pleaText = input_value
end

function refreshControlPanel()
	if not controlPanel then return end

	controlPanel.clearInputs()
	controlPanel.clearButtons()

	createControlPanelCallback()
end

function destroyControlPanel()
	if not controlPanel then return end
	controlPanel.destruct()
	controlPanel = nil
end

--- END CONTROL PANEL ---









--- BEGIN MAIN LOOP ---

function onUpdate()
	if not enabled then return end
	updatePlea()
	updateFigurine()
end

--- END MAIN LOOP ---










function math.sign(v)
	return (v >= 0 and 1) or -1
end

function math.round(v, bracket)
	bracket = bracket or 1
	return math.floor(v/bracket + math.sign(v) * 0.5) * bracket
end

function normalizeColor(color)
	return {
		r = math.round(color.r * 255),
		g = math.round(color.g * 255),
		b = math.round(color.b * 255)
	}
end

function colorCompare(a, b)
	return a.r == b.r and	a.g == b.g and a.b == b.b
end














--- BEGIN PLEA --

local plea3d = nil

local lastPleaTime = os.time()
function updatePlea()
	local now = os.time()
	local deltaTime = now - lastPleaTime

	if pleaText and string.len(pleaText) > 0 and deltaTime < pleaDisplaySeconds then
		createPlea3d()
		updatePlea3d()
	else
		removePlea3d()
	end

	if deltaTime > pleaDelay then
		lastPleaTime = now
	end
end

function createPlea3d()
	if plea3d then return end

	plea3d = spawnObject({
		type = '3DText',
		callback = 'plea3dCallback',
		callback_owner = self,
		position = { x = 0, y = -1, z = 0 }
	})
end

function plea3dCallback()
	plea3d.TextTool.setValue(pleaText)
	plea3d.TextTool.setFontColor(self.getColorTint())
	--plea3d.TextTool.setFontSize()
	--updatePlea3d()
end

-- the plea should follow the figurine around
function updatePlea3d()
	if not plea3d then return end

	local targetPosition = self.getPosition()
	local targetRotation = self.getRotation()

	targetPosition.y = targetPosition.y + 4 -- placeholder
	targetRotation.y = (targetRotation.y + 180) % 360

	plea3d.setPosition(targetPosition)
	plea3d.setRotation(targetRotation)
end

function removePlea3d()
	if not plea3d then return end
	plea3d.destruct()
	plea3d = nil
end

--- END PLEA --














local lastUpdateTime = os.time()
function updateFigurine()
	local now = os.time()
	local deltaTime = now - lastUpdateTime
	if deltaTime > 1 then

		local color = normalizeColor(self.getColorTint())
		debug = colorCompare(color, { r = 1, g = 1, b = 1 })
		wander()


		lastUpdateTime = now
	end
end

function shouldMove()
	if not enabled then return false end
	if self.getLock() then return false end
	if self.held_by_color then return false end
	if not self.resting then return false end

	return true
end

-- move forward until we hit something, then turn
function wander()
	if not shouldMove() then return end

	local targetPosition = self.getPosition()
	local targetRotation = self.getRotation()

	local distance = 1
	local directionTransform = self.getTransformForward()

	-- upright ourselves if needed
	if self.getTransformUp().y < 0 then
		targetRotation.x = 0
		targetRotation.z = 0
	end

	if not isPathObstructed(directionTransform, distance) then
		targetPosition = {
			x = targetPosition.x + directionTransform.x * distance,
			y = targetPosition.y + directionTransform.y * distance,
			z = targetPosition.z + directionTransform.z * distance
		}
	else
		local rotation = math.random(-180, 180)
		targetRotation.y = (targetRotation.y + rotation) % 360
	end

	self.setPositionSmooth(targetPosition)
	self.setRotationSmooth(targetRotation)
end

function isPathObstructed(direction, distance)
	local origin = self.getBounds().center

	local bounds = self.getBoundsNormalized()
	local sizeScale = 0.8
	local size = {
		x = bounds.size.x * sizeScale,
		y = bounds.size.y * sizeScale,
		z = bounds.size.z * sizeScale
	}

	local orientation = self.getRotation()

	local result = Physics.cast({
		origin = origin,
		direction = direction,
		type = 3,
		size = size,
		orientation = orientation,
		max_distance = distance,
		debug = debug
	})

	local foundHit = false
	for index, hit in ipairs(result) do
		if self ~= hit.hit_object then
			foundHit = true
		end
	end

	return foundHit
end
