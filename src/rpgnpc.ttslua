-- RPG NPC by Todd Ross
-- http://steamcommunity.com/sharedfiles/filedetails/?id=1198422406

local debug = false
local pleaDelay = 120
local pleaDisplaySeconds = 10
local timerId = 'RPGNPC' .. tostring({})

function onLoad(loadString)
	if string.len(loadString) > 0 then
		local saveState = JSON.decode(loadString)
	end
end

function onSave()
	return JSON.encode({})
end

local lastUpdateTime = os.time()
function onUpdate()
	updatePlea()
	local now = os.time()
	local deltaTime = now - lastUpdateTime
	if deltaTime > 1 then
		issueCommands()
		lastUpdateTime = now
	end
end

function math.sign(v)
	return (v >= 0 and 1) or -1
end

function math.round(v, bracket)
	bracket = bracket or 1
	return math.floor(v/bracket + math.sign(v) * 0.5) * bracket
end

function normalizeColor(color)
	return {
		r = math.round(color.r * 255),
		g = math.round(color.g * 255),
		b = math.round(color.b * 255)
	}
end

function colorCompare(a, b)
	return a.r == b.r and	a.g == b.g and a.b == b.b
end

function issueCommands()
	local color = normalizeColor(self.getColorTint())
	debug = colorCompare(color, { r = 1, g = 1, b = 1 })
	wander()
end

local plea3d = nil

local lastPleaTime = os.time()
function updatePlea()
	local now = os.time()
	local deltaTime = now - lastPleaTime

	local pleaText = self.getDescription()

	if string.len(pleaText) > 0 and deltaTime < pleaDisplaySeconds then
		createPlea3d()
		updatePlea3d()
	else
		removePlea3d()
	end

	if deltaTime > pleaDelay then
		lastPleaTime = now
	end
end

function createPlea3d()
	if plea3d then return end

	plea3d = spawnObject({
		type = '3DText',
		callback = 'plea3dCallback',
		callback_owner = self,
		position = { x = 0, y = -1, z = 0 }
	})
end

function plea3dCallback()
	plea3d.TextTool.setValue(self.getDescription())
	plea3d.TextTool.setFontColor(self.getColorTint())
	--plea3d.TextTool.setFontSize()
	updatePlea3d()
end

function updatePlea3d()
	if not plea3d then return end

	local targetPosition = self.getPosition()
	local targetRotation = self.getRotation()

	targetPosition.y = targetPosition.y + 4 -- placeholder
	targetRotation.y = (targetRotation.y + 180) % 360

	plea3d.setPosition(targetPosition)
	plea3d.setRotation(targetRotation)
end

function removePlea3d()
	if not plea3d then return end
	plea3d.destruct()
	plea3d = nil
end

function shouldMove()
	if self.getLock() then return false end
	if self.held_by_color then return false end
	if not self.resting then return false end

	return true
end

-- move forward until we hit something, then turn
function wander()
	if not shouldMove() then return end

	local targetPosition = self.getPosition()
	local targetRotation = self.getRotation()

	local distance = 1
	local directionTransform = self.getTransformForward()

	-- upright ourselves if needed
	if self.getTransformUp().y < 0 then
		targetRotation.x = 0
		targetRotation.z = 0
	end

	if not isPathObstructed(directionTransform, distance) then
		targetPosition = {
			x = targetPosition.x + directionTransform.x * distance,
			y = targetPosition.y + directionTransform.y * distance,
			z = targetPosition.z + directionTransform.z * distance
		}
	else
		local rotation = math.random(-180, 180)
		targetRotation.y = (targetRotation.y + rotation) % 360
	end

	self.setPositionSmooth(targetPosition)
	self.setRotationSmooth(targetRotation)
end

function isPathObstructed(direction, distance)
	local origin = self.getBounds().center

	local bounds = self.getBoundsNormalized()
	local sizeScale = 0.8
	local size = {
		x = bounds.size.x * sizeScale,
		y = bounds.size.y * sizeScale,
		z = bounds.size.z * sizeScale
	}

	local orientation = self.getRotation()

	local result = Physics.cast({
		origin = origin,
		direction = direction,
		type = 3,
		size = size,
		orientation = orientation,
		max_distance = distance,
		debug = debug
	})

	local foundHit = false
	for index, hit in ipairs(result) do
		if self ~= hit.hit_object then
			foundHit = true
		end
	end

	return foundHit
end
